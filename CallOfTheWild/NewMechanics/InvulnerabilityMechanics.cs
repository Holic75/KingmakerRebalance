using Kingmaker.Blueprints;
using Kingmaker.Blueprints.Facts;
using Kingmaker.PubSubSystem;
using Kingmaker.UnitLogic;
using Kingmaker.UnitLogic.Abilities;
using Kingmaker.UnitLogic.Buffs;
using Kingmaker.UnitLogic.Mechanics;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CallOfTheWild.InvulnerabilityMechanics
{
    public class UnitPartSpellInvulnerability : AdditiveUnitPart
    {
        public bool isImmune(AbilityExecutionContext context)
        {
            foreach (var b in buffs.ToArray())
            {
                bool res = false;
                b.CallComponents<ISpellInvulnerability>(i => res = i.isImmune(context));

                if (res)
                {
                    return true;
                }
            }
            return false;
        }
    }


    [AllowedOn(typeof(BlueprintUnitFact))]
    public abstract class ISpellInvulnerability : OwnedGameLogicComponent<UnitDescriptor>, IUnitSubscriber
    {
        public override void OnTurnOn()
        {
            this.Owner.Ensure<UnitPartSpellInvulnerability>().addBuff(this.Fact);
        }


        public override void OnTurnOff()
        {
            this.Owner.Ensure<UnitPartSpellInvulnerability>().removeBuff(this.Fact);
        }

        public abstract bool isImmune(AbilityExecutionContext context);
    }



    [AllowedOn(typeof(BlueprintUnitFact))]
    public class ImmunityUpToSpellLevel : ISpellInvulnerability
    {
        public ContextValue max_spell_level;

        public override bool isImmune(AbilityExecutionContext context)
        {
            var ability = context?.Ability;
            if (ability == null || !ability.Blueprint.IsSpell || ability.SpellLevel == 0)
            {
                return false;
            }

            return ability.SpellLevel <= max_spell_level.Calculate(this.Fact.MaybeContext);
        }
    }


    [AllowedOn(typeof(BlueprintUnitFact))]
    public class SpellLevelsImmunity : ISpellInvulnerability
    {
        public ContextValue spell_levels;
        private List<AbilityExecutionContext> context_checked = new List<AbilityExecutionContext>();
        [JsonProperty]
        private int remaining_levels;

        public override void OnTurnOn()
        {
            base.OnTurnOn();
            remaining_levels = spell_levels.Calculate(this.Fact.MaybeContext);
        }

        public override bool isImmune(AbilityExecutionContext context)
        {
            if (context_checked.Contains(context))
            {
                return true;
            }
            var ability = context?.Ability;
            if (ability == null || !ability.Blueprint.IsSpell || ability.SpellLevel == 0)
            {
                return false;
            }

            if (remaining_levels <= 0)
            {
                return false;
            }

            remaining_levels -= context.SpellLevel;
            context_checked.Add(context);
            if (remaining_levels <= 0)
            {
                remaining_levels = 0;
                (this.Fact as Buff)?.Remove();
            }
            Common.AddBattleLogMessage(this.Owner.CharacterName + "\'s " + this.Fact.Name + $" can absorb {remaining_levels} more spell levels");
            return true;
        }
    }

}
